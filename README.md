# milli-stress
milli-stress has functions to periodically saturate various physical subsystems
for a very short amount of time (order of milliseconds).

## CPU Stressor
The CPU stressor implements a Sieve of Erathostenes to check if a given number
is prime.

### Build
```
$ make
```

### Execution Parameters
```
$ ./milli-stress [n] [duration] [interval] [count]
```

Check if `n` is prime every `interval` seconds for `duration` seconds or
`count` times. If `duration = 0` and `count = 0`, it runs indefinitely.

### Running Example
The duration of a CPU saturation generated by this stressor is dependent on the
workload (i.e., the Sieve parameter `n`) and the hardware. Intuitively, a CPU
with higher clock rate should run the algorithm for a certain `n` faster than a
CPU with lower clock rate, given that other specifications like cache sizes are
the same, thus producing a briefer saturation.

In this running example, we show how to periodically saturate a single virtual
core of a C8220 machine for a few hundreds of milliseconds. This machine has two
10-core Intel Ivy Bridge CPUs at 2.20 GHz running Ubuntu 18.04 LTS 64 bits.
```
Architecture:        x86_64
CPU op-mode(s):      32-bit, 64-bit
Byte Order:          Little Endian
CPU(s):              40
On-line CPU(s) list: 0-39
Thread(s) per core:  2
Core(s) per socket:  10
Socket(s):           2
NUMA node(s):        2
Vendor ID:           GenuineIntel
CPU family:          6
Model:               62
Model name:          Intel(R) Xeon(R) CPU E5-2660 v2 @ 2.20GHz
Stepping:            4
CPU MHz:             2201.770
CPU max MHz:         2200.0000
CPU min MHz:         1200.0000
BogoMIPS:            4400.21
Virtualization:      VT-x
L1d cache:           32K
L1i cache:           32K
L2 cache:            256K
L3 cache:            25600K
```

The C8220 machine was hosted on CloudLab. An identical environment can be
instantiated using the public CloudLab profile
`Infosphere/C8220-Ubuntu18.04LTS64bit`.

To simplify the analysis, disable all but one virtual core. For the C8220
machine with 40 virtual cores (`cpu0`, `cpu1`, ..., `cpu39`):
```
$ sudo su
# for i in {1..39}; do echo "0" > /sys/devices/system/cpu/cpu$i/online; done
# exit
```

Run `lscpu` and check that only `cpu0` is on-line:
```
...
On-line CPU(s) list:  0
Off-line CPU(s) list: 1-39
...
```

For more reproducible results, disable any dynamic overclocking feature like
Intel TurboBoost. For the `intel_pstate` power scaling driver of modern Intel
CPUs:
```
$ sudo su
# echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo
# exit
```

Also, install the `cpupower` utility and activate the `performance` frequency
governor so the CPU runs at maximum frequency all the time. For Ubuntu 18.04
(Linux 4.0.15):
```
$ sudo apt-get update
$ sudo apt-get install linux-tools-common linux-tools-4.15.0-101-generic
$ sudo cpupower frequency-set -g performance
```

Run `cpupower frequency-info` and check that `cpu0` is running at maximum
frequency (2.20 GHz for the C8220 machine):
```
analyzing CPU 0:
  driver: intel_pstate
  CPUs which run at the same hardware frequency: 0
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency:  Cannot determine or is not supported.
  hardware limits: 1.20 GHz - 2.20 GHz
  available cpufreq governors: performance powersave
  current policy: frequency should be within 1.20 GHz and 2.20 GHz.
                  The governor "performance" may decide which speed to use
                  within this range.
  current CPU frequency: Unable to call hardware
  current CPU frequency: 2.20 GHz (asserted by call to kernel)
  boost state support:
    Supported: no
    Active: no
    25500 MHz max turbo 4 active cores
    25500 MHz max turbo 3 active cores
    25500 MHz max turbo 2 active cores
    25500 MHz max turbo 1 active cores
```

Install `Collectl` to monitor the CPU utilization:
```
$ sudo apt-get update
$ sudo apt-get install collectl
```

Clone this repository:
```
$ git clone https://github.com/rodrigoalveslima/milli-stress.git
$ cd milli-stress
```

Build the stressors:
```
$ make
```

Start monitoring the CPU utilization with a sampling interval of 50
milliseconds, generate CPU saturations that last around [TODO] milliseconds
every 5 seconds for 1 minute, and finally stop the monitor.
```
$ sudo nice -n -1 /usr/bin/collectl -sC -i.05 -oTm -P -f collectl & \
> ./milli-stress 10000000 60 5 0; \
> sudo pkill collectl
```

If you are using another hardware configuration or want to create saturations of
different duration, play with parameter `n`, as bigger values create longer
saturations. Also keep in mind that, according to the *Sampling Theorem*,
we need to sample at twice the frequency of the phenomenona we want to observe,
so that sampling interval of 50 milliseconds cannot detect saturations that last
for less than 100 milliseconds.

### Running Containerized Example
It is also possible to run `milli-stress` from within a Docker container,
using [`rAdvisor`](https://github.com/elba-docker/radvisor) as an alternative to Collectl
to instrument the CPU utilization.
This example has been run on the same machine as previously described,
so **the above instructions can be re-used up until the point of installing Collectl.**

Instead, [install Docker](https://docs.docker.com/engine/install/ubuntu/) if it is not already installed
(These instructions are for Ubuntu 18.04):
```
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE=DontWarn apt-key add -
$ sudo add-apt-repository \
  "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) \
  stable"
$ sudo apt-get update
$ sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
  containerd.io=1.2.10-3 \
  docker-ce=5:19.03.4~3-0~ubuntu-$(lsb_release -cs) \
  docker-ce-cli=5:19.03.4~3-0~ubuntu-$(lsb_release -cs)
$ cat <<EOF | sudo tee /etc/docker/daemon.json
{
  "exec-opts": ["native.cgroupdriver=systemd"],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m"
  },
  "storage-driver": "overlay2"
}
EOF
$ sudo mkdir -p /etc/systemd/system/docker.service.d
$ sudo systemctl daemon-reload
$ sudo systemctl restart docker
```

Clone this repository:
```
$ git clone https://github.com/rodrigoalveslima/milli-stress.git
$ cd milli-stress
```

Build and tag the container:
```
$ sudo docker build . --tag milli-stress
```

Download the [latest version of rAdvisor](https://github.com/elba-docker/radvisor/releases/latest):
```
$ curl -L https://github.com/elba-docker/radvisor/releases/download/v1.3.0/radvisor-linux-amd64 --output ./radvisor
$ chmod +x ./radvisor
```

Run `milli-stress` with the same config as the above example:
start monitoring the CPU utilization with a sampling interval of 50
milliseconds, generate CPU saturations that last around [TODO] milliseconds
every 5 seconds for 1 minute, and finally stop the monitor.
```
$ sudo nice -n -1 ./radvisor run docker --quiet --directory ./logs & \
  sudo docker run milli-stress 10000000 60 5 0; \
  sudo pkill radvisor
```
